// =================================================
//   !! <----->      DO NOT MODIFY      <-----> !!
//
//   This module was automatically generated by an
//   xtask
//
//   run `cargo xtask generate` from the workspace
//   to regenerate
//
// =================================================

use serde_derive::{Deserialize, Serialize};
use strum::{Display, EnumIter, EnumProperty, EnumString, FromRepr};

use crate::vm::object::traits::Programmable;
#[derive(
    Debug,
    Display,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Clone,
    Copy,
    Serialize,
    Deserialize,
    EnumIter,
    EnumString,
    EnumProperty,
    FromRepr,
)]
#[strum(use_phf, serialize_all = "lowercase")]
#[serde(rename_all = "lowercase")]
pub enum InstructionOp {
    Nop,
    #[strum(props(
        example = "abs r? a(r?|num)",
        desc = "Register = the absolute value of a",
        operands = "2"
    ))]
    Abs,
    #[strum(props(
        example = "acos r? a(r?|num)",
        desc = "Returns the cosine of the specified angle (radians)",
        operands = "2"
    ))]
    Acos,
    #[strum(props(
        example = "add r? a(r?|num) b(r?|num)",
        desc = "Register = a + b.",
        operands = "3"
    ))]
    Add,
    #[strum(props(
        example = "alias str r?|d?",
        desc = "Labels register or device reference with name, device references also affect what shows on the screws on the IC base.",
        operands = "2"
    ))]
    Alias,
    #[strum(props(
        example = "and r? a(r?|num) b(r?|num)",
        desc = "Performs a bitwise logical AND operation on the binary representation of two values. Each bit of the result is determined by evaluating the corresponding bits of the input values. If both bits are 1, the resulting bit is set to 1. Otherwise the resulting bit is set to 0.",
        operands = "3"
    ))]
    And,
    #[strum(props(
        example = "asin r? a(r?|num)",
        desc = "Returns the angle (radians) whos sine is the specified value",
        operands = "2"
    ))]
    Asin,
    #[strum(props(
        example = "atan r? a(r?|num)",
        desc = "Returns the angle (radians) whos tan is the specified value",
        operands = "2"
    ))]
    Atan,
    #[strum(props(
        example = "atan2 r? a(r?|num) b(r?|num)",
        desc = "Returns the angle (radians) whose tangent is the quotient of two specified values: a (y) and b (x)",
        operands = "3"
    ))]
    Atan2,
    #[strum(props(
        example = "bap a(r?|num) b(r?|num) c(r?|num) d(r?|num)",
        desc = "Branch to line d if abs(a - b) <= max(c * max(abs(a), abs(b)), float.epsilon * 8)",
        operands = "4"
    ))]
    Bap,
    #[strum(props(
        example = "bapal a(r?|num) b(r?|num) c(r?|num) d(r?|num)",
        desc = "Branch to line c if a != b and store next line number in ra",
        operands = "4"
    ))]
    Bapal,
    #[strum(props(
        example = "bapz a(r?|num) b(r?|num) c(r?|num)",
        desc = "Branch to line c if abs(a) <= max(b * abs(a), float.epsilon * 8)",
        operands = "3"
    ))]
    Bapz,
    #[strum(props(
        example = "bapzal a(r?|num) b(r?|num) c(r?|num)",
        desc = "Branch to line c if abs(a) <= max(b * abs(a), float.epsilon * 8) and store next line number in ra",
        operands = "3"
    ))]
    Bapzal,
    #[strum(props(
        example = "bdns d? a(r?|num)",
        desc = "Branch to line a if device d isn't set",
        operands = "2"
    ))]
    Bdns,
    #[strum(props(
        example = "bdnsal d? a(r?|num)",
        desc = "Jump execution to line a and store next line number if device is not set",
        operands = "2"
    ))]
    Bdnsal,
    #[strum(props(
        example = "bdse d? a(r?|num)",
        desc = "Branch to line a if device d is set",
        operands = "2"
    ))]
    Bdse,
    #[strum(props(
        example = "bdseal d? a(r?|num)",
        desc = "Jump execution to line a and store next line number if device is set",
        operands = "2"
    ))]
    Bdseal,
    #[strum(props(
        example = "beq a(r?|num) b(r?|num) c(r?|num)",
        desc = "Branch to line c if a == b",
        operands = "3"
    ))]
    Beq,
    #[strum(props(
        example = "beqal a(r?|num) b(r?|num) c(r?|num)",
        desc = "Branch to line c if a == b and store next line number in ra",
        operands = "3"
    ))]
    Beqal,
    #[strum(props(
        example = "beqz a(r?|num) b(r?|num)",
        desc = "Branch to line b if a == 0",
        operands = "2"
    ))]
    Beqz,
    #[strum(props(
        example = "beqzal a(r?|num) b(r?|num)",
        desc = "Branch to line b if a == 0 and store next line number in ra",
        operands = "2"
    ))]
    Beqzal,
    #[strum(props(
        example = "bge a(r?|num) b(r?|num) c(r?|num)",
        desc = "Branch to line c if a >= b",
        operands = "3"
    ))]
    Bge,
    #[strum(props(
        example = "bgeal a(r?|num) b(r?|num) c(r?|num)",
        desc = "Branch to line c if a >= b and store next line number in ra",
        operands = "3"
    ))]
    Bgeal,
    #[strum(props(
        example = "bgez a(r?|num) b(r?|num)",
        desc = "Branch to line b if a >= 0",
        operands = "2"
    ))]
    Bgez,
    #[strum(props(
        example = "bgezal a(r?|num) b(r?|num)",
        desc = "Branch to line b if a >= 0 and store next line number in ra",
        operands = "2"
    ))]
    Bgezal,
    #[strum(props(
        example = "bgt a(r?|num) b(r?|num) c(r?|num)",
        desc = "Branch to line c if a > b",
        operands = "3"
    ))]
    Bgt,
    #[strum(props(
        example = "bgtal a(r?|num) b(r?|num) c(r?|num)",
        desc = "Branch to line c if a > b and store next line number in ra",
        operands = "3"
    ))]
    Bgtal,
    #[strum(props(
        example = "bgtz a(r?|num) b(r?|num)",
        desc = "Branch to line b if a > 0",
        operands = "2"
    ))]
    Bgtz,
    #[strum(props(
        example = "bgtzal a(r?|num) b(r?|num)",
        desc = "Branch to line b if a > 0 and store next line number in ra",
        operands = "2"
    ))]
    Bgtzal,
    #[strum(props(
        example = "ble a(r?|num) b(r?|num) c(r?|num)",
        desc = "Branch to line c if a <= b",
        operands = "3"
    ))]
    Ble,
    #[strum(props(
        example = "bleal a(r?|num) b(r?|num) c(r?|num)",
        desc = "Branch to line c if a <= b and store next line number in ra",
        operands = "3"
    ))]
    Bleal,
    #[strum(props(
        example = "blez a(r?|num) b(r?|num)",
        desc = "Branch to line b if a <= 0",
        operands = "2"
    ))]
    Blez,
    #[strum(props(
        example = "blezal a(r?|num) b(r?|num)",
        desc = "Branch to line b if a <= 0 and store next line number in ra",
        operands = "2"
    ))]
    Blezal,
    #[strum(props(
        example = "blt a(r?|num) b(r?|num) c(r?|num)",
        desc = "Branch to line c if a < b",
        operands = "3"
    ))]
    Blt,
    #[strum(props(
        example = "bltal a(r?|num) b(r?|num) c(r?|num)",
        desc = "Branch to line c if a < b and store next line number in ra",
        operands = "3"
    ))]
    Bltal,
    #[strum(props(
        example = "bltz a(r?|num) b(r?|num)",
        desc = "Branch to line b if a < 0",
        operands = "2"
    ))]
    Bltz,
    #[strum(props(
        example = "bltzal a(r?|num) b(r?|num)",
        desc = "Branch to line b if a < 0 and store next line number in ra",
        operands = "2"
    ))]
    Bltzal,
    #[strum(props(
        example = "bna a(r?|num) b(r?|num) c(r?|num) d(r?|num)",
        desc = "Branch to line d if abs(a - b) > max(c * max(abs(a), abs(b)), float.epsilon * 8)",
        operands = "4"
    ))]
    Bna,
    #[strum(props(
        example = "bnaal a(r?|num) b(r?|num) c(r?|num) d(r?|num)",
        desc = "Branch to line d if abs(a - b) <= max(c * max(abs(a), abs(b)), float.epsilon * 8) and store next line number in ra",
        operands = "4"
    ))]
    Bnaal,
    #[strum(props(
        example = "bnan a(r?|num) b(r?|num)",
        desc = "Branch to line b if a is not a number (NaN)",
        operands = "2"
    ))]
    Bnan,
    #[strum(props(
        example = "bnaz a(r?|num) b(r?|num) c(r?|num)",
        desc = "Branch to line c if abs(a) > max (b * abs(a), float.epsilon * 8)",
        operands = "3"
    ))]
    Bnaz,
    #[strum(props(
        example = "bnazal a(r?|num) b(r?|num) c(r?|num)",
        desc = "Branch to line c if abs(a) > max (b * abs(a), float.epsilon * 8) and store next line number in ra",
        operands = "3"
    ))]
    Bnazal,
    #[strum(props(
        example = "bne a(r?|num) b(r?|num) c(r?|num)",
        desc = "Branch to line c if a != b",
        operands = "3"
    ))]
    Bne,
    #[strum(props(
        example = "bneal a(r?|num) b(r?|num) c(r?|num)",
        desc = "Branch to line c if a != b and store next line number in ra",
        operands = "3"
    ))]
    Bneal,
    #[strum(props(
        example = "bnez a(r?|num) b(r?|num)",
        desc = "branch to line b if a != 0",
        operands = "2"
    ))]
    Bnez,
    #[strum(props(
        example = "bnezal a(r?|num) b(r?|num)",
        desc = "Branch to line b if a != 0 and store next line number in ra",
        operands = "2"
    ))]
    Bnezal,
    #[strum(props(
        example = "brap a(r?|num) b(r?|num) c(r?|num) d(r?|num)",
        desc = "Relative branch to line d if abs(a - b) <= max(c * max(abs(a), abs(b)), float.epsilon * 8)",
        operands = "4"
    ))]
    Brap,
    #[strum(props(
        example = "brapz a(r?|num) b(r?|num) c(r?|num)",
        desc = "Relative branch to line c if abs(a) <= max(b * abs(a), float.epsilon * 8)",
        operands = "3"
    ))]
    Brapz,
    #[strum(props(
        example = "brdns d? a(r?|num)",
        desc = "Relative jump to line a if device is not set",
        operands = "2"
    ))]
    Brdns,
    #[strum(props(
        example = "brdse d? a(r?|num)",
        desc = "Relative jump to line a if device is set",
        operands = "2"
    ))]
    Brdse,
    #[strum(props(
        example = "breq a(r?|num) b(r?|num) c(r?|num)",
        desc = "Relative branch to line c if a == b",
        operands = "3"
    ))]
    Breq,
    #[strum(props(
        example = "breqz a(r?|num) b(r?|num)",
        desc = "Relative branch to line b if a == 0",
        operands = "2"
    ))]
    Breqz,
    #[strum(props(
        example = "brge a(r?|num) b(r?|num) c(r?|num)",
        desc = "Relative jump to line c if a >= b",
        operands = "3"
    ))]
    Brge,
    #[strum(props(
        example = "brgez a(r?|num) b(r?|num)",
        desc = "Relative branch to line b if a >= 0",
        operands = "2"
    ))]
    Brgez,
    #[strum(props(
        example = "brgt a(r?|num) b(r?|num) c(r?|num)",
        desc = "relative jump to line c if a > b",
        operands = "3"
    ))]
    Brgt,
    #[strum(props(
        example = "brgtz a(r?|num) b(r?|num)",
        desc = "Relative branch to line b if a > 0",
        operands = "2"
    ))]
    Brgtz,
    #[strum(props(
        example = "brle a(r?|num) b(r?|num) c(r?|num)",
        desc = "Relative jump to line c if a <= b",
        operands = "3"
    ))]
    Brle,
    #[strum(props(
        example = "brlez a(r?|num) b(r?|num)",
        desc = "Relative branch to line b if a <= 0",
        operands = "2"
    ))]
    Brlez,
    #[strum(props(
        example = "brlt a(r?|num) b(r?|num) c(r?|num)",
        desc = "Relative jump to line c if a < b",
        operands = "3"
    ))]
    Brlt,
    #[strum(props(
        example = "brltz a(r?|num) b(r?|num)",
        desc = "Relative branch to line b if a < 0",
        operands = "2"
    ))]
    Brltz,
    #[strum(props(
        example = "brna a(r?|num) b(r?|num) c(r?|num) d(r?|num)",
        desc = "Relative branch to line d if abs(a - b) > max(c * max(abs(a), abs(b)), float.epsilon * 8)",
        operands = "4"
    ))]
    Brna,
    #[strum(props(
        example = "brnan a(r?|num) b(r?|num)",
        desc = "Relative branch to line b if a is not a number (NaN)",
        operands = "2"
    ))]
    Brnan,
    #[strum(props(
        example = "brnaz a(r?|num) b(r?|num) c(r?|num)",
        desc = "Relative branch to line c if abs(a) > max(b * abs(a), float.epsilon * 8)",
        operands = "3"
    ))]
    Brnaz,
    #[strum(props(
        example = "brne a(r?|num) b(r?|num) c(r?|num)",
        desc = "Relative branch to line c if a != b",
        operands = "3"
    ))]
    Brne,
    #[strum(props(
        example = "brnez a(r?|num) b(r?|num)",
        desc = "Relative branch to line b if a != 0",
        operands = "2"
    ))]
    Brnez,
    #[strum(props(
        example = "ceil r? a(r?|num)",
        desc = "Register = smallest integer greater than a",
        operands = "2"
    ))]
    Ceil,
    #[strum(props(
        example = "clr d?",
        desc = "Clears the stack memory for the provided device.",
        operands = "1"
    ))]
    Clr,
    #[strum(props(
        example = "clrd id(r?|num)",
        desc = "Seeks directly for the provided device id and clears the stack memory of that device",
        operands = "1"
    ))]
    Clrd,
    #[strum(props(
        example = "cos r? a(r?|num)",
        desc = "Returns the cosine of the specified angle (radians)",
        operands = "2"
    ))]
    Cos,
    #[strum(props(
        example = "define str num",
        desc = "Creates a label that will be replaced throughout the program with the provided value.",
        operands = "2"
    ))]
    Define,
    #[strum(props(
        example = "div r? a(r?|num) b(r?|num)",
        desc = "Register = a / b",
        operands = "3"
    ))]
    Div,
    #[strum(props(
        example = "exp r? a(r?|num)",
        desc = "Register = exp(a) or e^a",
        operands = "2"
    ))]
    Exp,
    #[strum(props(
        example = "floor r? a(r?|num)",
        desc = "Register = largest integer less than a",
        operands = "2"
    ))]
    Floor,
    #[strum(props(
        example = "get r? d? address(r?|num)",
        desc = "Using the provided device, attempts to read the stack value at the provided address, and places it in the register.",
        operands = "3"
    ))]
    Get,
    #[strum(props(
        example = "getd r? id(r?|num) address(r?|num)",
        desc = "Seeks directly for the provided device id, attempts to read the stack value at the provided address, and places it in the register.",
        operands = "3"
    ))]
    Getd,
    #[strum(props(example = "hcf", desc = "Halt and catch fire", operands = "0"))]
    Hcf,
    #[strum(props(example = "j int", desc = "Jump execution to line a", operands = "1"))]
    J,
    #[strum(props(
        example = "jal int",
        desc = "Jump execution to line a and store next line number in ra",
        operands = "1"
    ))]
    Jal,
    #[strum(props(example = "jr int", desc = "Relative jump to line a", operands = "1"))]
    Jr,
    #[strum(props(
        example = "l r? d? logicType",
        desc = "Loads device LogicType to register by housing index value.",
        operands = "3"
    ))]
    L,
    #[strum(props(example = "label d? str", desc = "DEPRECATED", operands = "2"))]
    Label,
    #[strum(props(
        example = "lb r? deviceHash logicType batchMode",
        desc = "Loads LogicType from all output network devices with provided type hash using the provide batch mode. Average (0), Sum (1), Minimum (2), Maximum (3). Can use either the word, or the number.",
        operands = "4"
    ))]
    Lb,
    #[strum(props(
        example = "lbn r? deviceHash nameHash logicType batchMode",
        desc = "Loads LogicType from all output network devices with provided type and name hashes using the provide batch mode. Average (0), Sum (1), Minimum (2), Maximum (3). Can use either the word, or the number.",
        operands = "5"
    ))]
    Lbn,
    #[strum(props(
        example = "lbns r? deviceHash nameHash slotIndex logicSlotType batchMode",
        desc = "Loads LogicSlotType from slotIndex from all output network devices with provided type and name hashes using the provide batch mode. Average (0), Sum (1), Minimum (2), Maximum (3). Can use either the word, or the number.",
        operands = "6"
    ))]
    Lbns,
    #[strum(props(
        example = "lbs r? deviceHash slotIndex logicSlotType batchMode",
        desc = "Loads LogicSlotType from slotIndex from all output network devices with provided type hash using the provide batch mode. Average (0), Sum (1), Minimum (2), Maximum (3). Can use either the word, or the number.",
        operands = "5"
    ))]
    Lbs,
    #[strum(props(
        example = "ld r? id(r?|num) logicType",
        desc = "Loads device LogicType to register by direct ID reference.",
        operands = "3"
    ))]
    Ld,
    #[strum(props(
        example = "log r? a(r?|num)",
        desc = "Register = base e log(a) or ln(a)",
        operands = "2"
    ))]
    Log,
    #[strum(props(
        example = "lr r? d? reagentMode int",
        desc = "Loads reagent of device's ReagentMode where a hash of the reagent type to check for. ReagentMode can be either Contents (0), Required (1), Recipe (2). Can use either the word, or the number.",
        operands = "4"
    ))]
    Lr,
    #[strum(props(
        example = "ls r? d? slotIndex logicSlotType",
        desc = "Loads slot LogicSlotType on device to register.",
        operands = "4"
    ))]
    Ls,
    #[strum(props(
        example = "max r? a(r?|num) b(r?|num)",
        desc = "Register = max of a or b",
        operands = "3"
    ))]
    Max,
    #[strum(props(
        example = "min r? a(r?|num) b(r?|num)",
        desc = "Register = min of a or b",
        operands = "3"
    ))]
    Min,
    #[strum(props(
        example = "mod r? a(r?|num) b(r?|num)",
        desc = "Register = a mod b (note: NOT a % b)",
        operands = "3"
    ))]
    Mod,
    #[strum(props(
        example = "move r? a(r?|num)",
        desc = "Register = provided num or register value.",
        operands = "2"
    ))]
    Move,
    #[strum(props(
        example = "mul r? a(r?|num) b(r?|num)",
        desc = "Register = a * b",
        operands = "3"
    ))]
    Mul,
    #[strum(props(
        example = "nor r? a(r?|num) b(r?|num)",
        desc = "Performs a bitwise logical NOR (NOT OR) operation on the binary representation of two values. Each bit of the result is determined by evaluating the corresponding bits of the input values. If both bits are 0, the resulting bit is set to 1. Otherwise, if at least one bit is 1, the resulting bit is set to 0.",
        operands = "3"
    ))]
    Nor,
    #[strum(props(
        example = "not r? a(r?|num)",
        desc = "Performs a bitwise logical NOT operation flipping each bit of the input value, resulting in a binary complement. If a bit is 1, it becomes 0, and if a bit is 0, it becomes 1.",
        operands = "2"
    ))]
    Not,
    #[strum(props(
        example = "or r? a(r?|num) b(r?|num)",
        desc = "Performs a bitwise logical OR operation on the binary representation of two values. Each bit of the result is determined by evaluating the corresponding bits of the input values. If either bit is 1, the resulting bit is set to 1. If both bits are 0, the resulting bit is set to 0.",
        operands = "3"
    ))]
    Or,
    #[strum(props(
        example = "peek r?",
        desc = "Register = the value at the top of the stack",
        operands = "1"
    ))]
    Peek,
    #[strum(props(
        example = "poke address(r?|num) value(r?|num)",
        desc = "Stores the provided value at the provided address in the stack.",
        operands = "2"
    ))]
    Poke,
    #[strum(props(
        example = "pop r?",
        desc = "Register = the value at the top of the stack and decrements sp",
        operands = "1"
    ))]
    Pop,
    #[strum(props(
        example = "push a(r?|num)",
        desc = "Pushes the value of a to the stack at sp and increments sp",
        operands = "1"
    ))]
    Push,
    #[strum(props(
        example = "put d? address(r?|num) value(r?|num)",
        desc = "Using the provided device, attempts to write the provided value to the stack at the provided address.",
        operands = "3"
    ))]
    Put,
    #[strum(props(
        example = "putd id(r?|num) address(r?|num) value(r?|num)",
        desc = "Seeks directly for the provided device id, attempts to write the provided value to the stack at the provided address.",
        operands = "3"
    ))]
    Putd,
    #[strum(props(
        example = "rand r?",
        desc = "Register = a random value x with 0 <= x < 1",
        operands = "1"
    ))]
    Rand,
    #[strum(props(
        example = "round r? a(r?|num)",
        desc = "Register = a rounded to nearest integer",
        operands = "2"
    ))]
    Round,
    #[strum(props(
        example = "s d? logicType r?",
        desc = "Stores register value to LogicType on device by housing index value.",
        operands = "3"
    ))]
    S,
    #[strum(props(
        example = "sap r? a(r?|num) b(r?|num) c(r?|num)",
        desc = "Register = 1 if abs(a - b) <= max(c * max(abs(a), abs(b)), float.epsilon * 8), otherwise 0",
        operands = "4"
    ))]
    Sap,
    #[strum(props(
        example = "sapz r? a(r?|num) b(r?|num)",
        desc = "Register = 1 if abs(a) <= max(b * abs(a), float.epsilon * 8), otherwise 0",
        operands = "3"
    ))]
    Sapz,
    #[strum(props(
        example = "sb deviceHash logicType r?",
        desc = "Stores register value to LogicType on all output network devices with provided type hash.",
        operands = "3"
    ))]
    Sb,
    #[strum(props(
        example = "sbn deviceHash nameHash logicType r?",
        desc = "Stores register value to LogicType on all output network devices with provided type hash and name.",
        operands = "4"
    ))]
    Sbn,
    #[strum(props(
        example = "sbs deviceHash slotIndex logicSlotType r?",
        desc = "Stores register value to LogicSlotType on all output network devices with provided type hash in the provided slot.",
        operands = "4"
    ))]
    Sbs,
    #[strum(props(
        example = "sd id(r?|num) logicType r?",
        desc = "Stores register value to LogicType on device by direct ID reference.",
        operands = "3"
    ))]
    Sd,
    #[strum(props(
        example = "sdns r? d?",
        desc = "Register = 1 if device is not set, otherwise 0",
        operands = "2"
    ))]
    Sdns,
    #[strum(props(
        example = "sdse r? d?",
        desc = "Register = 1 if device is set, otherwise 0.",
        operands = "2"
    ))]
    Sdse,
    #[strum(props(
        example = "select r? a(r?|num) b(r?|num) c(r?|num)",
        desc = "Register = b if a is non-zero, otherwise c",
        operands = "4"
    ))]
    Select,
    #[strum(props(
        example = "seq r? a(r?|num) b(r?|num)",
        desc = "Register = 1 if a == b, otherwise 0",
        operands = "3"
    ))]
    Seq,
    #[strum(props(
        example = "seqz r? a(r?|num)",
        desc = "Register = 1 if a == 0, otherwise 0",
        operands = "2"
    ))]
    Seqz,
    #[strum(props(
        example = "sge r? a(r?|num) b(r?|num)",
        desc = "Register = 1 if a >= b, otherwise 0",
        operands = "3"
    ))]
    Sge,
    #[strum(props(
        example = "sgez r? a(r?|num)",
        desc = "Register = 1 if a >= 0, otherwise 0",
        operands = "2"
    ))]
    Sgez,
    #[strum(props(
        example = "sgt r? a(r?|num) b(r?|num)",
        desc = "Register = 1 if a > b, otherwise 0",
        operands = "3"
    ))]
    Sgt,
    #[strum(props(
        example = "sgtz r? a(r?|num)",
        desc = "Register = 1 if a > 0, otherwise 0",
        operands = "2"
    ))]
    Sgtz,
    #[strum(props(
        example = "sin r? a(r?|num)",
        desc = "Returns the sine of the specified angle (radians)",
        operands = "2"
    ))]
    Sin,
    #[strum(props(
        example = "sla r? a(r?|num) b(r?|num)",
        desc = "Performs a bitwise arithmetic left shift operation on the binary representation of a value. It shifts the bits to the left and fills the vacated rightmost bits with a copy of the sign bit (the most significant bit).",
        operands = "3"
    ))]
    Sla,
    #[strum(props(
        example = "sle r? a(r?|num) b(r?|num)",
        desc = "Register = 1 if a <= b, otherwise 0",
        operands = "3"
    ))]
    Sle,
    #[strum(props(
        example = "sleep a(r?|num)",
        desc = "Pauses execution on the IC for a seconds",
        operands = "1"
    ))]
    Sleep,
    #[strum(props(
        example = "slez r? a(r?|num)",
        desc = "Register = 1 if a <= 0, otherwise 0",
        operands = "2"
    ))]
    Slez,
    #[strum(props(
        example = "sll r? a(r?|num) b(r?|num)",
        desc = "Performs a bitwise logical left shift operation on the binary representation of a value. It shifts the bits to the left and fills the vacated rightmost bits with zeros.",
        operands = "3"
    ))]
    Sll,
    #[strum(props(
        example = "slt r? a(r?|num) b(r?|num)",
        desc = "Register = 1 if a < b, otherwise 0",
        operands = "3"
    ))]
    Slt,
    #[strum(props(
        example = "sltz r? a(r?|num)",
        desc = "Register = 1 if a < 0, otherwise 0",
        operands = "2"
    ))]
    Sltz,
    #[strum(props(
        example = "sna r? a(r?|num) b(r?|num) c(r?|num)",
        desc = "Register = 1 if abs(a - b) > max(c * max(abs(a), abs(b)), float.epsilon * 8), otherwise 0",
        operands = "4"
    ))]
    Sna,
    #[strum(props(
        example = "snan r? a(r?|num)",
        desc = "Register = 1 if a is NaN, otherwise 0",
        operands = "2"
    ))]
    Snan,
    #[strum(props(
        example = "snanz r? a(r?|num)",
        desc = "Register = 0 if a is NaN, otherwise 1",
        operands = "2"
    ))]
    Snanz,
    #[strum(props(
        example = "snaz r? a(r?|num) b(r?|num)",
        desc = "Register = 1 if abs(a) > max(b * abs(a), float.epsilon), otherwise 0",
        operands = "3"
    ))]
    Snaz,
    #[strum(props(
        example = "sne r? a(r?|num) b(r?|num)",
        desc = "Register = 1 if a != b, otherwise 0",
        operands = "3"
    ))]
    Sne,
    #[strum(props(
        example = "snez r? a(r?|num)",
        desc = "Register = 1 if a != 0, otherwise 0",
        operands = "2"
    ))]
    Snez,
    #[strum(props(
        example = "sqrt r? a(r?|num)",
        desc = "Register = square root of a",
        operands = "2"
    ))]
    Sqrt,
    #[strum(props(
        example = "sra r? a(r?|num) b(r?|num)",
        desc = "Performs a bitwise arithmetic right shift operation on the binary representation of a value. It shifts the bits to the right and fills the vacated leftmost bits with a copy of the sign bit (the most significant bit).",
        operands = "3"
    ))]
    Sra,
    #[strum(props(
        example = "srl r? a(r?|num) b(r?|num)",
        desc = "Performs a bitwise logical right shift operation on the binary representation of a value. It shifts the bits to the right and fills the vacated leftmost bits with zeros",
        operands = "3"
    ))]
    Srl,
    #[strum(props(
        example = "ss d? slotIndex logicSlotType r?",
        desc = "Stores register value to device stored in a slot LogicSlotType on device.",
        operands = "4"
    ))]
    Ss,
    #[strum(props(
        example = "sub r? a(r?|num) b(r?|num)",
        desc = "Register = a - b.",
        operands = "3"
    ))]
    Sub,
    #[strum(props(
        example = "tan r? a(r?|num)",
        desc = "Returns the tan of the specified angle (radians) ",
        operands = "2"
    ))]
    Tan,
    #[strum(props(
        example = "trunc r? a(r?|num)",
        desc = "Register = a with fractional part removed",
        operands = "2"
    ))]
    Trunc,
    #[strum(props(
        example = "xor r? a(r?|num) b(r?|num)",
        desc = "Performs a bitwise logical XOR (exclusive OR) operation on the binary representation of two values. Each bit of the result is determined by evaluating the corresponding bits of the input values. If the bits are different (one bit is 0 and the other is 1), the resulting bit is set to 1. If the bits are the same (both 0 or both 1), the resulting bit is set to 0.",
        operands = "3"
    ))]
    Xor,
    #[strum(props(
        example = "yield",
        desc = "Pauses execution for 1 tick",
        operands = "0"
    ))]
    Yield,
}
impl InstructionOp {
    pub fn num_operands(&self) -> usize {
        self.get_str("operands")
            .expect("instruction without operand property")
            .parse::<usize>()
            .expect("invalid instruction operand property")
    }

    pub fn execute<T>(
        &self,
        ic: &mut T,
        vm: &crate::vm::VM,
        operands: &[crate::vm::instructions::operands::Operand],
    ) -> Result<(), crate::errors::ICError>
    where
        T: Programmable,
    {
        let num_operands = self.num_operands();
        if operands.len() != num_operands {
            return Err(crate::errors::ICError::mismatch_operands(
                operands.len(),
                num_operands as u32,
            ));
        }
        match self {
            Self::Nop => Ok(()),
            Self::Abs => ic.execute_abs(vm, &operands[0], &operands[1]),
            Self::Acos => ic.execute_acos(vm, &operands[0], &operands[1]),
            Self::Add => ic.execute_add(vm, &operands[0], &operands[1], &operands[2]),
            Self::Alias => ic.execute_alias(vm, &operands[0], &operands[1]),
            Self::And => ic.execute_and(vm, &operands[0], &operands[1], &operands[2]),
            Self::Asin => ic.execute_asin(vm, &operands[0], &operands[1]),
            Self::Atan => ic.execute_atan(vm, &operands[0], &operands[1]),
            Self::Atan2 => ic.execute_atan2(vm, &operands[0], &operands[1], &operands[2]),
            Self::Bap => ic.execute_bap(vm, &operands[0], &operands[1], &operands[2], &operands[3]),
            Self::Bapal => {
                ic.execute_bapal(vm, &operands[0], &operands[1], &operands[2], &operands[3])
            }
            Self::Bapz => ic.execute_bapz(vm, &operands[0], &operands[1], &operands[2]),
            Self::Bapzal => ic.execute_bapzal(vm, &operands[0], &operands[1], &operands[2]),
            Self::Bdns => ic.execute_bdns(vm, &operands[0], &operands[1]),
            Self::Bdnsal => ic.execute_bdnsal(vm, &operands[0], &operands[1]),
            Self::Bdse => ic.execute_bdse(vm, &operands[0], &operands[1]),
            Self::Bdseal => ic.execute_bdseal(vm, &operands[0], &operands[1]),
            Self::Beq => ic.execute_beq(vm, &operands[0], &operands[1], &operands[2]),
            Self::Beqal => ic.execute_beqal(vm, &operands[0], &operands[1], &operands[2]),
            Self::Beqz => ic.execute_beqz(vm, &operands[0], &operands[1]),
            Self::Beqzal => ic.execute_beqzal(vm, &operands[0], &operands[1]),
            Self::Bge => ic.execute_bge(vm, &operands[0], &operands[1], &operands[2]),
            Self::Bgeal => ic.execute_bgeal(vm, &operands[0], &operands[1], &operands[2]),
            Self::Bgez => ic.execute_bgez(vm, &operands[0], &operands[1]),
            Self::Bgezal => ic.execute_bgezal(vm, &operands[0], &operands[1]),
            Self::Bgt => ic.execute_bgt(vm, &operands[0], &operands[1], &operands[2]),
            Self::Bgtal => ic.execute_bgtal(vm, &operands[0], &operands[1], &operands[2]),
            Self::Bgtz => ic.execute_bgtz(vm, &operands[0], &operands[1]),
            Self::Bgtzal => ic.execute_bgtzal(vm, &operands[0], &operands[1]),
            Self::Ble => ic.execute_ble(vm, &operands[0], &operands[1], &operands[2]),
            Self::Bleal => ic.execute_bleal(vm, &operands[0], &operands[1], &operands[2]),
            Self::Blez => ic.execute_blez(vm, &operands[0], &operands[1]),
            Self::Blezal => ic.execute_blezal(vm, &operands[0], &operands[1]),
            Self::Blt => ic.execute_blt(vm, &operands[0], &operands[1], &operands[2]),
            Self::Bltal => ic.execute_bltal(vm, &operands[0], &operands[1], &operands[2]),
            Self::Bltz => ic.execute_bltz(vm, &operands[0], &operands[1]),
            Self::Bltzal => ic.execute_bltzal(vm, &operands[0], &operands[1]),
            Self::Bna => ic.execute_bna(vm, &operands[0], &operands[1], &operands[2], &operands[3]),
            Self::Bnaal => {
                ic.execute_bnaal(vm, &operands[0], &operands[1], &operands[2], &operands[3])
            }
            Self::Bnan => ic.execute_bnan(vm, &operands[0], &operands[1]),
            Self::Bnaz => ic.execute_bnaz(vm, &operands[0], &operands[1], &operands[2]),
            Self::Bnazal => ic.execute_bnazal(vm, &operands[0], &operands[1], &operands[2]),
            Self::Bne => ic.execute_bne(vm, &operands[0], &operands[1], &operands[2]),
            Self::Bneal => ic.execute_bneal(vm, &operands[0], &operands[1], &operands[2]),
            Self::Bnez => ic.execute_bnez(vm, &operands[0], &operands[1]),
            Self::Bnezal => ic.execute_bnezal(vm, &operands[0], &operands[1]),
            Self::Brap => {
                ic.execute_brap(vm, &operands[0], &operands[1], &operands[2], &operands[3])
            }
            Self::Brapz => ic.execute_brapz(vm, &operands[0], &operands[1], &operands[2]),
            Self::Brdns => ic.execute_brdns(vm, &operands[0], &operands[1]),
            Self::Brdse => ic.execute_brdse(vm, &operands[0], &operands[1]),
            Self::Breq => ic.execute_breq(vm, &operands[0], &operands[1], &operands[2]),
            Self::Breqz => ic.execute_breqz(vm, &operands[0], &operands[1]),
            Self::Brge => ic.execute_brge(vm, &operands[0], &operands[1], &operands[2]),
            Self::Brgez => ic.execute_brgez(vm, &operands[0], &operands[1]),
            Self::Brgt => ic.execute_brgt(vm, &operands[0], &operands[1], &operands[2]),
            Self::Brgtz => ic.execute_brgtz(vm, &operands[0], &operands[1]),
            Self::Brle => ic.execute_brle(vm, &operands[0], &operands[1], &operands[2]),
            Self::Brlez => ic.execute_brlez(vm, &operands[0], &operands[1]),
            Self::Brlt => ic.execute_brlt(vm, &operands[0], &operands[1], &operands[2]),
            Self::Brltz => ic.execute_brltz(vm, &operands[0], &operands[1]),
            Self::Brna => {
                ic.execute_brna(vm, &operands[0], &operands[1], &operands[2], &operands[3])
            }
            Self::Brnan => ic.execute_brnan(vm, &operands[0], &operands[1]),
            Self::Brnaz => ic.execute_brnaz(vm, &operands[0], &operands[1], &operands[2]),
            Self::Brne => ic.execute_brne(vm, &operands[0], &operands[1], &operands[2]),
            Self::Brnez => ic.execute_brnez(vm, &operands[0], &operands[1]),
            Self::Ceil => ic.execute_ceil(vm, &operands[0], &operands[1]),
            Self::Clr => ic.execute_clr(vm, &operands[0]),
            Self::Clrd => ic.execute_clrd(vm, &operands[0]),
            Self::Cos => ic.execute_cos(vm, &operands[0], &operands[1]),
            Self::Define => ic.execute_define(vm, &operands[0], &operands[1]),
            Self::Div => ic.execute_div(vm, &operands[0], &operands[1], &operands[2]),
            Self::Exp => ic.execute_exp(vm, &operands[0], &operands[1]),
            Self::Floor => ic.execute_floor(vm, &operands[0], &operands[1]),
            Self::Get => ic.execute_get(vm, &operands[0], &operands[1], &operands[2]),
            Self::Getd => ic.execute_getd(vm, &operands[0], &operands[1], &operands[2]),
            Self::Hcf => ic.execute_hcf(vm),
            Self::J => ic.execute_j(vm, &operands[0]),
            Self::Jal => ic.execute_jal(vm, &operands[0]),
            Self::Jr => ic.execute_jr(vm, &operands[0]),
            Self::L => ic.execute_l(vm, &operands[0], &operands[1], &operands[2]),
            Self::Label => ic.execute_label(vm, &operands[0], &operands[1]),
            Self::Lb => ic.execute_lb(vm, &operands[0], &operands[1], &operands[2], &operands[3]),
            Self::Lbn => ic.execute_lbn(
                vm,
                &operands[0],
                &operands[1],
                &operands[2],
                &operands[3],
                &operands[4],
            ),
            Self::Lbns => ic.execute_lbns(
                vm,
                &operands[0],
                &operands[1],
                &operands[2],
                &operands[3],
                &operands[4],
                &operands[5],
            ),
            Self::Lbs => ic.execute_lbs(
                vm,
                &operands[0],
                &operands[1],
                &operands[2],
                &operands[3],
                &operands[4],
            ),
            Self::Ld => ic.execute_ld(vm, &operands[0], &operands[1], &operands[2]),
            Self::Log => ic.execute_log(vm, &operands[0], &operands[1]),
            Self::Lr => ic.execute_lr(vm, &operands[0], &operands[1], &operands[2], &operands[3]),
            Self::Ls => ic.execute_ls(vm, &operands[0], &operands[1], &operands[2], &operands[3]),
            Self::Max => ic.execute_max(vm, &operands[0], &operands[1], &operands[2]),
            Self::Min => ic.execute_min(vm, &operands[0], &operands[1], &operands[2]),
            Self::Mod => ic.execute_mod(vm, &operands[0], &operands[1], &operands[2]),
            Self::Move => ic.execute_move(vm, &operands[0], &operands[1]),
            Self::Mul => ic.execute_mul(vm, &operands[0], &operands[1], &operands[2]),
            Self::Nor => ic.execute_nor(vm, &operands[0], &operands[1], &operands[2]),
            Self::Not => ic.execute_not(vm, &operands[0], &operands[1]),
            Self::Or => ic.execute_or(vm, &operands[0], &operands[1], &operands[2]),
            Self::Peek => ic.execute_peek(vm, &operands[0]),
            Self::Poke => ic.execute_poke(vm, &operands[0], &operands[1]),
            Self::Pop => ic.execute_pop(vm, &operands[0]),
            Self::Push => ic.execute_push(vm, &operands[0]),
            Self::Put => ic.execute_put(vm, &operands[0], &operands[1], &operands[2]),
            Self::Putd => ic.execute_putd(vm, &operands[0], &operands[1], &operands[2]),
            Self::Rand => ic.execute_rand(vm, &operands[0]),
            Self::Round => ic.execute_round(vm, &operands[0], &operands[1]),
            Self::S => ic.execute_s(vm, &operands[0], &operands[1], &operands[2]),
            Self::Sap => ic.execute_sap(vm, &operands[0], &operands[1], &operands[2], &operands[3]),
            Self::Sapz => ic.execute_sapz(vm, &operands[0], &operands[1], &operands[2]),
            Self::Sb => ic.execute_sb(vm, &operands[0], &operands[1], &operands[2]),
            Self::Sbn => ic.execute_sbn(vm, &operands[0], &operands[1], &operands[2], &operands[3]),
            Self::Sbs => ic.execute_sbs(vm, &operands[0], &operands[1], &operands[2], &operands[3]),
            Self::Sd => ic.execute_sd(vm, &operands[0], &operands[1], &operands[2]),
            Self::Sdns => ic.execute_sdns(vm, &operands[0], &operands[1]),
            Self::Sdse => ic.execute_sdse(vm, &operands[0], &operands[1]),
            Self::Select => {
                ic.execute_select(vm, &operands[0], &operands[1], &operands[2], &operands[3])
            }
            Self::Seq => ic.execute_seq(vm, &operands[0], &operands[1], &operands[2]),
            Self::Seqz => ic.execute_seqz(vm, &operands[0], &operands[1]),
            Self::Sge => ic.execute_sge(vm, &operands[0], &operands[1], &operands[2]),
            Self::Sgez => ic.execute_sgez(vm, &operands[0], &operands[1]),
            Self::Sgt => ic.execute_sgt(vm, &operands[0], &operands[1], &operands[2]),
            Self::Sgtz => ic.execute_sgtz(vm, &operands[0], &operands[1]),
            Self::Sin => ic.execute_sin(vm, &operands[0], &operands[1]),
            Self::Sla => ic.execute_sla(vm, &operands[0], &operands[1], &operands[2]),
            Self::Sle => ic.execute_sle(vm, &operands[0], &operands[1], &operands[2]),
            Self::Sleep => ic.execute_sleep(vm, &operands[0]),
            Self::Slez => ic.execute_slez(vm, &operands[0], &operands[1]),
            Self::Sll => ic.execute_sll(vm, &operands[0], &operands[1], &operands[2]),
            Self::Slt => ic.execute_slt(vm, &operands[0], &operands[1], &operands[2]),
            Self::Sltz => ic.execute_sltz(vm, &operands[0], &operands[1]),
            Self::Sna => ic.execute_sna(vm, &operands[0], &operands[1], &operands[2], &operands[3]),
            Self::Snan => ic.execute_snan(vm, &operands[0], &operands[1]),
            Self::Snanz => ic.execute_snanz(vm, &operands[0], &operands[1]),
            Self::Snaz => ic.execute_snaz(vm, &operands[0], &operands[1], &operands[2]),
            Self::Sne => ic.execute_sne(vm, &operands[0], &operands[1], &operands[2]),
            Self::Snez => ic.execute_snez(vm, &operands[0], &operands[1]),
            Self::Sqrt => ic.execute_sqrt(vm, &operands[0], &operands[1]),
            Self::Sra => ic.execute_sra(vm, &operands[0], &operands[1], &operands[2]),
            Self::Srl => ic.execute_srl(vm, &operands[0], &operands[1], &operands[2]),
            Self::Ss => ic.execute_ss(vm, &operands[0], &operands[1], &operands[2], &operands[3]),
            Self::Sub => ic.execute_sub(vm, &operands[0], &operands[1], &operands[2]),
            Self::Tan => ic.execute_tan(vm, &operands[0], &operands[1]),
            Self::Trunc => ic.execute_trunc(vm, &operands[0], &operands[1]),
            Self::Xor => ic.execute_xor(vm, &operands[0], &operands[1], &operands[2]),
            Self::Yield => ic.execute_yield(vm),
        }
    }
}
