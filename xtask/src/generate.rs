use color_eyre::eyre;

use std::{collections::BTreeMap, process::Command};

use crate::{enums::Enums, stationpedia::Stationpedia};

mod database;
mod enums;
mod instructions;
mod utils;

pub fn generate(
    stationpedia_path: &std::path::Path,
    workspace: &std::path::Path,
) -> color_eyre::Result<()> {
    let mut pedia: Stationpedia = parse_json(&mut serde_json::Deserializer::from_reader(
        std::io::BufReader::new(std::fs::File::open(
            stationpedia_path.join("Stationpedia.json"),
        )?),
    ))?;

    let instruction_help_patches: BTreeMap<String, String> = parse_json(
        &mut serde_json::Deserializer::from_reader(std::io::BufReader::new(std::fs::File::open(
            workspace.join("data").join("instruction_help_patches.json"),
        )?)),
    )?;

    for (inst, patch) in instruction_help_patches {
        if let Some(cmd) = pedia.script_commands.get_mut(&inst) {
            cmd.desc = patch;
        } else {
            eprintln!("Warning: can find instruction '{inst}' to patch help!");
        }
    }

    let enums: Enums = parse_json(&mut serde_json::Deserializer::from_reader(
        std::io::BufReader::new(std::fs::File::open(stationpedia_path.join("Enums.json"))?),
    ))?;

    database::generate_database(&pedia, &enums, workspace)?;
    let enums_files = enums::generate_enums(&pedia, &enums, workspace)?;
    let inst_files = instructions::generate_instructions(&pedia, workspace)?;

    let generated_files = [enums_files.as_slice(), inst_files.as_slice()].concat();

    eprintln!("Formatting generated files...");
    for file in &generated_files {
        prepend_genereated_comment(file)?;
    }
    let mut cmd = Command::new("cargo");
    cmd.current_dir(workspace);
    cmd.arg("fmt").arg("--");
    cmd.args(&generated_files);
    cmd.status()?;
    Ok(())
}

pub fn parse_json<'a, T: serde::Deserialize<'a>>(
    jd: impl serde::Deserializer<'a>,
) -> Result<T, color_eyre::Report> {
    let mut track = serde_path_to_error::Track::new();
    let path = serde_path_to_error::Deserializer::new(jd, &mut track);
    let mut fun = |path: serde_ignored::Path| {
        tracing::warn!(key=%path,"Found ignored key");
    };
    serde_ignored::deserialize(path, &mut fun).map_err(|e| {
        eyre::eyre!(
            "path: {track} | error = {e}",
            track = track.path().to_string(),
        )
    })
}

fn prepend_genereated_comment(file_path: &std::path::Path) -> color_eyre::Result<()> {
    use std::io::Write;
    let tmp_path = file_path.with_extension("rs.tmp");
    {
        let mut tmp = std::fs::File::create(&tmp_path)?;
        let mut src = std::fs::File::open(file_path)?;
        write!(
            &mut tmp,
            "// ================================================= \n\
             //   !! <----->      DO NOT MODIFY      <-----> !! \n\
             // \n\
             //   This module was automatically generated by an
             //   xtask \n\
             // \n\
             //   run `cargo xtask generate` from the workspace \n\
             //   to regenerate \n\
             // \n\
             // ================================================= \n\
             \n\
             \n\
            "
        )?;
        std::io::copy(&mut src, &mut tmp)?;
    }
    std::fs::remove_file(file_path)?;
    std::fs::rename(&tmp_path, file_path)?;
    Ok(())
}
