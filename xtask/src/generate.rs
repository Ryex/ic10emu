use color_eyre::eyre;
use quote::ToTokens;

use std::collections::BTreeMap;

use crate::{enums::Enums, stationpedia::Stationpedia};

mod database;
mod enums;
mod instructions;
mod utils;

pub fn generate(
    stationpedia_path: &std::path::Path,
    workspace: &std::path::Path,
    modules: &[&str],
) -> color_eyre::Result<()> {
    let mut pedia: Stationpedia = parse_json(&mut serde_json::Deserializer::from_reader(
        std::io::BufReader::new(std::fs::File::open(
            stationpedia_path.join("Stationpedia.json"),
        )?),
    ))?;

    let instruction_help_patches: BTreeMap<String, String> = parse_json(
        &mut serde_json::Deserializer::from_reader(std::io::BufReader::new(std::fs::File::open(
            workspace.join("data").join("instruction_help_patches.json"),
        )?)),
    )?;

    for (inst, patch) in instruction_help_patches {
        if let Some(cmd) = pedia.script_commands.get_mut(&inst) {
            cmd.desc = patch;
        } else {
            eprintln!("Warning: can find instruction '{inst}' to patch help!");
        }
    }

    let enums: Enums = parse_json(&mut serde_json::Deserializer::from_reader(
        std::io::BufReader::new(std::fs::File::open(stationpedia_path.join("Enums.json"))?),
    ))?;

    let mut generated_files = Vec::new();
    if modules.contains(&"enums") {
        if modules.len() > 1 {
            eprintln!(
                "generating enums alone, recompile the xtask and run again with other modules."
            )
        } else {
            eprintln!("generating enums...");
        }

        let enums_files = enums::generate(&pedia, &enums, workspace)?;
        eprintln!("Formatting generated files...");
        for file in &enums_files {
            prepend_generated_comment_and_format(file)?;
        }
        return Ok(());
    }

    if modules.contains(&"database") {
        eprintln!("generating database...");

        let database_files = database::generate_database(&pedia, &enums, workspace)?;
        generated_files.extend(database_files);
    }

    if modules.contains(&"instructions") {
        eprintln!("generating instructions...");
        let inst_files = instructions::generate_instructions(&pedia, workspace)?;
        generated_files.extend(inst_files);
    }

    eprintln!("Formatting generated files...");
    for file in &generated_files {
        prepend_generated_comment_and_format(file)?;
    }
    Ok(())
}

pub fn parse_json<'a, T: serde::Deserialize<'a>>(
    jd: impl serde::Deserializer<'a>,
) -> Result<T, color_eyre::Report> {
    let mut track = serde_path_to_error::Track::new();
    let path = serde_path_to_error::Deserializer::new(jd, &mut track);
    let mut fun = |path: serde_ignored::Path| {
        tracing::warn!(key=%path,"Found ignored key");
    };
    serde_ignored::deserialize(path, &mut fun).map_err(|e| {
        eyre::eyre!(
            "path: {track} | error = {e}",
            track = track.path().to_string(),
        )
    })
}

fn format_rust(content: impl ToTokens) -> color_eyre::Result<String> {
    let content = syn::parse2(content.to_token_stream())?;
    Ok(prettyplease::unparse(&content))
}

fn prepend_generated_comment_and_format(file_path: &std::path::Path) -> color_eyre::Result<()> {
    use std::io::Write;
    let tmp_path = file_path.with_extension("rs.tmp");
    {
        let mut tmp = std::fs::File::create(&tmp_path)?;
        let src = syn::parse_file(&std::fs::read_to_string(file_path)?)?;

        let formated = format_rust(quote::quote! {
            // =================================================
            //   !! <----->      DO NOT MODIFY      <-----> !!
            //
            //   This module was automatically generated by an
            //   xtask
            //
            //   run `cargo xtask generate` from the workspace
            //   to regenerate
            //
            // =================================================

            #src
        })?;

        write!(&mut tmp, "{formated}")?;
    }
    std::fs::remove_file(file_path)?;
    std::fs::rename(&tmp_path, file_path)?;
    Ok(())
}
