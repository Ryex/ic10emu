use color_eyre::eyre;
use quote::ToTokens;

use std::collections::BTreeMap;

use crate::{enums::Enums, stationpedia::Stationpedia};

mod database;
mod enums;
mod instructions;
mod utils;

pub fn generate(
    stationpedia_path: &std::path::Path,
    workspace: &std::path::Path,
    modules: &[&str],
) -> color_eyre::Result<()> {
    let mut pedia: Stationpedia = parse_json(&mut serde_json::Deserializer::from_reader(
        std::io::BufReader::new(std::fs::File::open(
            stationpedia_path.join("Stationpedia.json"),
        )?),
    ))?;

    let instruction_help_patches: BTreeMap<String, String> = parse_json(
        &mut serde_json::Deserializer::from_reader(std::io::BufReader::new(std::fs::File::open(
            workspace.join("data").join("instruction_help_patches.json"),
        )?)),
    )?;

    for (inst, patch) in instruction_help_patches {
        if let Some(cmd) = pedia.script_commands.get_mut(&inst) {
            cmd.desc = patch;
        } else {
            eprintln!("Warning: can find instruction '{inst}' to patch help!");
        }
    }

    let enums: Enums = parse_json(&mut serde_json::Deserializer::from_reader(
        std::io::BufReader::new(std::fs::File::open(stationpedia_path.join("Enums.json"))?),
    ))?;

    let mut generated_files = Vec::new();
    if modules.contains(&"enums") {
        if modules.len() > 1 {
            eprintln!(
                "generating enums alone, recompile the xtask and run again with other modules."
            )
        } else {
            eprintln!("generating enums...");
        }

        let enums_files = enums::generate(&pedia, &enums, workspace)?;
        eprintln!("Formatting generated files...");
        for file in &enums_files {
            prepend_generated_comment_and_format(file, "enums")?;
        }
        return Ok(());
    }

    if modules.contains(&"database") {
        eprintln!("generating database...");

        let database_files = database::generate_database(&pedia, &enums, workspace)?;
        generated_files.extend(database_files.into_iter().map(|path| (path, "database")));
    }

    if modules.contains(&"instructions") {
        eprintln!("generating instructions...");
        let inst_files = instructions::generate_instructions(&pedia, workspace)?;
        generated_files.extend(inst_files.into_iter().map(|path| (path, "instructions")));
    }

    eprintln!("Formatting generated files...");
    for (file, module) in &generated_files {
        prepend_generated_comment_and_format(file, module)?;
    }
    Ok(())
}

pub fn parse_json<'a, T: serde::Deserialize<'a>>(
    jd: impl serde::Deserializer<'a>,
) -> Result<T, color_eyre::Report> {
    let mut track = serde_path_to_error::Track::new();
    let path = serde_path_to_error::Deserializer::new(jd, &mut track);
    let mut fun = |path: serde_ignored::Path| {
        tracing::warn!(key=%path,"Found ignored key");
    };
    serde_ignored::deserialize(path, &mut fun).map_err(|e| {
        eyre::eyre!(
            "path: {track} | error = {e}",
            track = track.path().to_string(),
        )
    })
}

fn format_rust(content: impl ToTokens) -> color_eyre::Result<String> {
    let content = syn::parse2(content.to_token_stream())?;
    Ok(prettyplease::unparse(&content))
}

fn prepend_generated_comment_and_format(file_path: &std::path::Path, module: &str) -> color_eyre::Result<()> {
    use std::io::Write;
    let tmp_path = file_path.with_extension("rs.tmp");
    {
        let mut tmp = std::fs::File::create(&tmp_path)?;
        let src = syn::parse_file(&std::fs::read_to_string(file_path)?)?;

        let formated = format_rust(src)?;

        write!(&mut tmp, "\
            // =================================================\n\
            //   !! <----->      DO NOT MODIFY      <-----> !!\n\
            //\n\
            //   This module was automatically generated by an\n\
            //   xtask\n\
            //\n\
            //   run\n\
            //\n\
            //   `cargo xtask generate -m {module}` \n\
            //\n\
            //   from the workspace to regenerate\n\
            //\n\
            // =================================================\n\
            \n\
            {formated}\
            "
        )?;
    }
    std::fs::remove_file(file_path)?;
    std::fs::rename(&tmp_path, file_path)?;
    Ok(())
}
